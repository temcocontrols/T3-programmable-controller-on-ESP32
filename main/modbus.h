#ifndef __MODBUS_H
#define	__MODBUS_H

#include <string.h>
#include "ud_str.h"
//#include "crc.h"


#define TXEN		PAout(8)
#define SEND			1			//1
#define	RECEIVE		0
//#define	READ_VARIABLES				0x03
//#define	WRITE_VARIABLES				0x06
#define	MULTIPLE_WRITE_VARIABLES				0x10
#define	CHECKONLINE					0x19
#define DATABUFLEN					200
#define DATABUFLEN_SCAN				12
#define SENDPOOLLEN         		8
#define SERIAL_COM_IDLE				0
#define INVALID_PACKET				1
#define VALID_PACKET				2
#define USART_REC_LEN  			512
#define USART_SEND_LEN			512

#define TEMCO_MODBUS 		0xff

#define READ_VARIABLES      3
#define WRITE_VARIABLES     6
#define MULTIPLE_WRITE		16
#define CHECKONLINE				0x19

#define		SW_OFF 	 0
#define 	SW_HAND	 2
#define		SW_AUTO	 1

// *******************modbus.h***********************************
// Header file containing all of the register information for modbus
// serial communications.
// V.24 first release of modbus.h file.
// V.25
//caution:the tstat response should have a pause between two characrers,but the maximum allowed pause is 1.5 character times or .83 ms * 1.5 or 1.245 ms at 9600 baud.
//  REGISTER ADDRESSES TO BE USED IN MODBUS SERIAL COMMUNICATION
typedef enum
{
 	UART_1200 = 0,
	UART_2400,
	UART_3600,
	UART_4800,
	UART_7200,
	UART_9600,
	UART_19200,
	UART_38400,
	//UART_57600,
	UART_76800,
	UART_115200,
	UART_921600,
	UART_57600,
	UART_BAUDRATE_MAX

}E_BAUD;

enum {
	SERIALNUMBER_LOWORD =0   ,          // -	-	Lower 2 bytes of the serial number
	SERIALNUMBER_HIWORD  = 2  ,		// -	-	Upper 2 bytes of teh serial number
	VERSION_NUMBER_LO   = 4  ,		// -	-	Software version
	VERSION_NUMBER_HI,				// -	-	Software version
	MODBUS_ADDRESS,							// 1	254	Device modbus address
	PRODUCT_MODEL,					// -	-	Temco Product Model	1=Tstat5B, 2=Tstat5A, 4=Tstat5C, 12=Tstat5D,
	HARDWARE_REV,					// -	-	Hardware Revision
	PIC882VERSION,						// -	-	PIC firmware version
	PLUG_N_PLAY,				// -	-	Temporary address for plug-n-play addressing scheme
	ISP_MODE_INDICATION,
	MODBUS_UART0_BAUDRATE = 12,	// 0	1	Baudrate 0 = 9.6kb/s, 1 = 19.2kb/s
	MODBUS_ISP_VER = 14,
	UPDATE_STATUS	= 16,			// reg 16 status for update_flash											// writing 0x7F means jump to ISP routine											// writing 0x8F means completely erase eeprom

	MODBUS_UART1_BAUDRATE = 17,
	MODBUS_UART2_BAUDRATE = 18,
	MODBUS_COM0_TYPE,
	MODBUS_COM1_TYPE,
	MODBUS_COM2_TYPE,
	MODBUS_ETHERNET_STATUS	= 22,





	MODBUS_INSTANCE_HI = 32,
	MODBUS_MINI_TYPE = 34,
	MODBUS_INSTANCE_LO = 35,  //
	MODBUS_PANEL_NUMBER = 36,
	MODBUS_STATION_NUM = 42,  // MSTP ID
	MODBUS_NETWORK_NUMBER = 46,

	MAC_ADDR_1 = 60,
	MAC_ADDR_2,
	MAC_ADDR_3,
	MAC_ADDR_4,
	MAC_ADDR_5,
	MAC_ADDR_6, //65
	IP_MODE, //66
	IP_ADDR_1,
	IP_ADDR_2,
	IP_ADDR_3,
	IP_ADDR_4,
	IP_SUB_MASK_1,//71
	IP_SUB_MASK_2,
	IP_SUB_MASK_3,
	IP_SUB_MASK_4,
	IP_GATE_WAY_1,
	IP_GATE_WAY_2,
	IP_GATE_WAY_3,
	IP_GATE_WAY_4,
	WIFI_FAC,//79
	WIFI_RSSI, //80

	MODBUS_RUN_TIME_LO = 94,
	MODBUS_RUN_TIME_HI,

	MODBUS_TIMER_ADDRESS = 200, // 200

	MODBUS_TOTAL_NO = 299  ,  // NUMBER OF ZONES

	MODBUS_SUBADDR_FIRST = 300 ,	// 193
	MODBUS_SUBADDR_LAST = 400 , // 200

/******** WIFI START ************************/
	MODBUS_WIFI_START = 2000,
	MODBUS_WIFI_SSID_MANUAL_EN = 2000,  // 2001 ~ 2009 reserved
	MODBUS_WIFI_MODE, // 0-AUTO 1-STATIC
	MODBUS_WIFI_STATUS,
	MODBUS_WIFI_RESTORE,
	MODBUS_WIFI_MODBUS_PORT,
	MODBUS_WIFI_BACNET_PORT,
	MODBUS_WIFI_REV, // current is 2
	MODBUS_WIIF_START_SMART,
	MODBUS_WIFI_WRITE_MAC,

	MODBUS_WIFI_SSID_START = 2010,	// 2010 ~ 2041 user name 64 bytes
	MODBUS_WIFI_SSID_END = 2041,
	MODBUS_WIFI_PASS_START = 2042,	// 2042 ~ 2057 password 32 bytes
	MODBUS_WIFI_PASS_END = 2057,

	MODBUS_WIFI_IP1 = 2058 ,
	MODBUS_WIFI_NETMASK = 2062,
	MODBUS_WIFI_GETWAY = 2066,
	MDOBUS_WIFI_MACADDR = 2070,

	MODBUS_WIFI_END = 2100,
/******** WIFI END ************************/


    MODBUS_TEST_1 = 7000,
	MODBUS_TEST_50 = 7049,


	MODBUS_IO_REG_START = 7100,
	MODBUS_OUTPUT_FIRST = 7100,
	MODBUS_OUTPUT_LAST = MODBUS_OUTPUT_FIRST + MAX_OUTS * 2 - 1,

	MODBUS_OUTPUT_SWICH_FIRST ,	// 7228
	MODBUS_OUTPUT_SWICH_LAST = MODBUS_OUTPUT_SWICH_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_RANGE_FIRST,  // 7292
	MODBUS_OUTPUT_RANGE_LAST = MODBUS_OUTPUT_RANGE_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_AM_FIRST,  // 7356
	MODBUS_OUTPUT_AM_LAST = MODBUS_OUTPUT_AM_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_AD_FIRST,  // 7420  ANALOG OR DIGITAL
	MODBUS_OUTPUT_AD_LAST = MODBUS_OUTPUT_AD_FIRST + MAX_OUTS - 1,


	MODBUS_INPUT_FIRST,	  // 7484
	MODBUS_INPUT_LAST = MODBUS_INPUT_FIRST + MAX_INS * 2- 1,

	MODBUS_INPUT_FILTER_FIRST,	// 7612
	MODBUS_INPUT_FILTER_LAST = MODBUS_INPUT_FILTER_FIRST + MAX_OUTS - 1,

	MODBUS_INPUT_CAL_FIRST,	  // 7676
	MODBUS_INPUT_CAL_LAST = MODBUS_INPUT_CAL_FIRST + MAX_INS - 1,

	MODBUS_INPUT_CAL_SIGN_FIRST,  // 7740
	MODBUS_INPUT_CAL_SIGN_LAST =  MODBUS_INPUT_CAL_SIGN_FIRST + MAX_INS - 1,

	MODBUS_INPUT_RANGE_FIRST,	  // 7804
	MODBUS_INPUT_RANGE_LAST = MODBUS_INPUT_RANGE_FIRST + MAX_INS - 1,

	MODBUS_INPUT_AM_FIRST,  // 7868
	MODBUS_INPUT_AM_LAST = MODBUS_INPUT_AM_FIRST + MAX_INS - 1,

  MODBUS_INPUT_HI_SPD_COUNTER_FIRST,	  // 7932
	MODBUS_INPUT_HI_SPD_COUNTER_LAST = MODBUS_INPUT_HI_SPD_COUNTER_FIRST + 32/*HI_COMMON_CHANNEL*/ * 2 - 1,

	MODBUS_INPUT_HI_SPD_EN_FIRST, //7996
	MODBUS_INPUT_HI_SPD_EN_LAST = MODBUS_INPUT_HI_SPD_EN_FIRST + 32/*HI_COMMON_CHANNEL*/ - 1,

	MODBUS_INPUT_TYPE_FIRST, // 8028
	MODBUS_INPUT_TYPE_LAST = MODBUS_INPUT_TYPE_FIRST + MAX_INS - 1,

	MODBUS_VAR_FIRST, // 8092
	MODBUS_VAR_LAST = MODBUS_VAR_FIRST + MAX_VARS * 2 - 1,

	MODBUS_VAR_AM_FIRST,  // 8348
	MODBUS_VAR_AM_LAST = MODBUS_VAR_AM_FIRST + MAX_VARS - 1,

	// add weekly roution
	MODBUS_WR_AM_FIRST, // 8476
	MODBUS_WR_AM_LAST = MODBUS_WR_AM_FIRST + MAX_WR - 1,

	MODBUS_WR_OUT_FIRST, // 8484
	MODBUS_WR_OUT_LAST = MODBUS_WR_OUT_FIRST + MAX_WR - 1,

	MODBUS_WR_HOLIDAY1_FIRST, // 8492
	MODBUS_WR_HOLIDAY1_LAST = MODBUS_WR_HOLIDAY1_FIRST + MAX_WR - 1,

	MODBUS_WR_STATE1_FIRST,  // 8500
	MODBUS_WR_STATE1_LAST = MODBUS_WR_STATE1_FIRST + MAX_WR - 1,

	MODBUS_WR_HOLIDAY2_FIRST, // 8508
	MODBUS_WR_HOLIDAY2_LAST = MODBUS_WR_HOLIDAY2_FIRST + MAX_WR - 1,

	MODBUS_WR_STATE2_FIRST,  // 8516
	MODBUS_WR_STATE2_LAST = MODBUS_WR_STATE2_FIRST + MAX_WR - 1,

	// weekly_time
	//	MODBUS_WR_TIME_BYTE_FIRST,
	//	MODBUS_WR_TIME_BYTE_LAST = MODBUS_WR_TIME_BYTE_FIRST + MAX_WR * MAX_SCHEDULES_PER_WEEK * 8 - 1,

	// annual roution
	MODBUS_AR_AM_FIRST,  // 8524
	MODBUS_AR_AM_LAST = MODBUS_AR_AM_FIRST + MAX_AR - 1,

	MODBUS_AR_OUT_FIRST, // 8528 - 8659
	MODBUS_AR_OUT_LAST = MODBUS_AR_OUT_FIRST + MAX_AR - 1,

//	MODBUS_ID_FIRST, // 8532
//	MODBUS_ID_LAST = MODBUS_ID_FIRST + MAX_ID * ID_SIZE - 1,
//	MODBUS_AR_TIME_BYTE_FIRST,
//	MODBUS_AR_TIME_BYTE_LAST = MODBUS_AR_TIME_BYTE_FIRST + MAX_AR * AR_DATES_SIZE - 1,
	MODBUS_VAR_RANGE_FIRST,  // 8532 - 8659
	MODBUS_VAR_RANGE_LAST = MODBUS_VAR_RANGE_FIRST + MAX_VARS - 1,

	MODBUS_VAR_AD_FIRST,  // 8660 - 8787
	MODBUS_VAR_AD_LAST = MODBUS_VAR_AD_FIRST + MAX_VARS - 1,


	MODBUS_OUTPUT_RELINQUISH_START = 9400,
	MODBUS_OUTPUT_RELINQUISH_END = MODBUS_OUTPUT_RELINQUISH_START + 2 * MAX_OUTS - 1,  // 128

	MODBUS_IO_REG_END = MODBUS_OUTPUT_RELINQUISH_END,



/*********FOR CALIBRATE HUM SENSOR******************/
	MODBUS_SETTING_BLOCK_FIRST = 9800,
	MODBUS_USER_BLOCK_FIRST = MODBUS_SETTING_BLOCK_FIRST,

	MODBUS_SETTING_BLOCK_LAST = 9999,

	MODBUS_OUTPUT_BLOCK_FIRST = 10000,     // 10000 -  11471  45
	MODBUS_OUTPUT_BLOCK_LAST = MODBUS_OUTPUT_BLOCK_FIRST + MAX_OUTS * ((sizeof(Str_out_point) + 1) / 2) - 1,

	MODBUS_INPUT_BLOCK_FIRST, // 11472 - 12943   46
	MODBUS_INPUT_BLOCK_LAST = MODBUS_INPUT_BLOCK_FIRST + MAX_INS * ((sizeof(Str_in_point) + 1) / 2) - 1,

	MODBUS_VAR_BLOCK_FIRST,  // 12944 - 15503  39
	MODBUS_VAR_BLOCK_LAST = MODBUS_VAR_BLOCK_FIRST + MAX_VARS * ((sizeof(Str_variable_point) + 1) / 2) - 1,

	MODBUS_PRG_BLOCK_FIRST, // 15504 - 15807   37
	MODBUS_PRG_BLOCK_LAST = MODBUS_PRG_BLOCK_FIRST + MAX_PRGS * ((sizeof(Str_program_point) + 1) / 2) - 1,

	MODBUS_WR_BLOCK_FIRST,  // 15808 -  15975    42
	MODBUS_WR_BLOCK_LAST = MODBUS_WR_BLOCK_FIRST + MAX_WR * ((sizeof(Str_weekly_routine_point) + 1) / 2) - 1,

	MODBUS_AR_BLOCK_FIRST,  // 15976 - 16043   33
	MODBUS_AR_BLOCK_LAST = MODBUS_AR_BLOCK_FIRST + MAX_AR * ((sizeof(Str_annual_routine_point) + 1) / 2) - 1,

	MODBUS_CODE_BLOCK_FIRST, // 16044 - 32043
	MODBUS_CODE_BLOCK_LAST = MODBUS_CODE_BLOCK_FIRST + MAX_PRGS * (CODE_ELEMENT * MAX_CODE / 2) - 1,

	MODBUS_WR_TIME_FIRST,  // 32044 - 32619
	MODBUS_WR_TIME_LAST = MODBUS_WR_TIME_FIRST + MAX_WR * ((sizeof(Wr_one_day) * MAX_SCHEDULES_PER_WEEK + 1) / 2) - 1,

	MODBUS_AR_TIME_FIRST, // 32620 - 32711  46
	MODBUS_AR_TIME_LAST = MODBUS_AR_TIME_FIRST + MAX_AR * (AR_DATES_SIZE / 2) - 1,

	MODBUS_CONTROLLER_BLOCK_FIRST,  // 32712 - 32935  28*16
	MODBUS_CONTROLLER_BLOCK_LAST = MODBUS_CONTROLLER_BLOCK_FIRST + MAX_CONS * ((sizeof(Str_controller_point) + 1) / 2) - 1,

//	MODBUS_WR_FIRST,
//	MODBUS_WR_LAST = MODBUS_WR_FIRST + MAX_WR * sizeof(Str_weekly_routine_point),
//
//	MODBUS_AR_FIRST,
//	MODBUS_AR_LAST = MODBUS_AR_FIRST + MAX_AR * sizeof(Str_annual_routine_point),
//
//
//	MODBUS_SUB_INFO_FIRST = 18000,
//	MODBUS_SUB_INFO_LAST = MODBUS_SUB_INFO_FIRST + SUB_NO * Tst_reg_num,


// add customer range
	MODBUS_CUSTOMER_RANGE_BLOCK_FIRST,  // 32936 - 33200  53 * 5
	MODBUS_CUSTOMER_RANGE_BLOCK_LAST = MODBUS_CUSTOMER_RANGE_BLOCK_FIRST + MAX_TBLS * ((sizeof(Str_table_point) + 1) / 2) - 1,

	MODBUS_WR_FLAG_FIRST,  // 33201 - 33488  wr_time_on_off   8 * 9 * 4
	MDOBUS_WR_FLAG_LAST = MODBUS_WR_FLAG_FIRST + MAX_WR * ((MAX_SCHEDULES_PER_WEEK * 8 + 1) / 2) - 1,

	//MODBUS_DIGITAL_TABLE_FIRST, // 33489 - 33592  digi_units 25/2 * 8
	//MODBUS_DIGITAL_TABLE_LAST = MODBUS_DIGITAL_TABLE_FIRST + MAX_DIG_UNIT * ((sizeof(Units_element) + 1) / 2) - 1,

	MODBUS_USER_BLOCK_LAST = MDOBUS_WR_FLAG_LAST,
//--------------------------------------------

	MODBUS_EX_MOUDLE_EN = 65000,
	MODBUS_EX_MOUDLE_FLAG12 = 65001,
	MODBUS_EX_MOUDLE_FLAG34 = 65002,
};

uint16_t read_IO_reg(uint16_t addr);
void Write_IO_reg(uint16_t StartAdd,uint8_t * pData);
void MulWrite_IO_reg(uint16_t StartAdd,uint8_t * pData);


//extern uint8_t dealwithTag ;

//void serial_restart(void);

//void modbus_data_cope(u8 XDATA* pData, u16 length, u8 conn_id) ;
extern void uart_init(uint8_t uart) ;
extern void stm32_uart_init(void);
//uint8_t checkCrc(void);


#endif
void responseModbusCmd(uint8_t type, uint8_t *pData, uint16_t len,uint8_t *resData ,uint16_t *modbus_send_len,uint8_t port);
