#ifndef __MODBUS_H
#define	__MODBUS_H

#include <string.h>
#include "ud_str.h"
//#include "crc.h"


#define TXEN		PAout(8)
#define SEND			1			//1
#define	RECEIVE		0
//#define	READ_VARIABLES				0x03
//#define	WRITE_VARIABLES				0x06
#define	MULTIPLE_WRITE_VARIABLES				0x10
#define	CHECKONLINE					0x19
#define DATABUFLEN					200
#define DATABUFLEN_SCAN				12
#define SENDPOOLLEN         		8
#define SERIAL_COM_IDLE				0
#define INVALID_PACKET				1
#define VALID_PACKET				2
#define USART_REC_LEN  			512
#define USART_SEND_LEN			512

#define TEMCO_MODBUS 		0xff

#define READ_VARIABLES      3
#define WRITE_VARIABLES     6
#define MULTIPLE_WRITE		16
#define CHECKONLINE				0x19

#define		SW_OFF 	 0
#define 	SW_HAND	 2
#define		SW_AUTO	 1


#define BASE_AIRLAB 50000
#define BASE_CO2	52000

// *******************modbus.h***********************************
// Header file containing all of the register information for modbus
// serial communications.
// V.24 first release of modbus.h file.
// V.25
//caution:the tstat response should have a pause between two characrers,but the maximum allowed pause is 1.5 character times or .83 ms * 1.5 or 1.245 ms at 9600 baud.
//  REGISTER ADDRESSES TO BE USED IN MODBUS SERIAL COMMUNICATION
typedef enum
{
 	UART_1200 = 0,
	UART_2400,
	UART_3600,
	UART_4800,
	UART_7200,
	UART_9600,
	UART_19200,
	UART_38400,
	//UART_57600,
	UART_76800,
	UART_115200,
	UART_921600,
	UART_57600,
	UART_BAUDRATE_MAX

}E_BAUD;

enum {
	SERIALNUMBER_LOWORD =0   ,          // -	-	Lower 2 bytes of the serial number
	SERIALNUMBER_HIWORD  = 2  ,		// -	-	Upper 2 bytes of teh serial number
	VERSION_NUMBER_LO   = 4  ,		// -	-	Software version
	VERSION_NUMBER_HI,				// -	-	Software version
	MODBUS_ADDRESS,							// 1	254	Device modbus address
	PRODUCT_MODEL,					// -	-	Temco Product Model	1=Tstat5B, 2=Tstat5A, 4=Tstat5C, 12=Tstat5D,
	HARDWARE_REV,					// -	-	Hardware Revision

	MODBUS_UART0_BAUDRATE = 12,	// 0	1	Baudrate 0 = 9.6kb/s, 1 = 19.2kb/s
	MODBUS_ISP_VER = 14,
	UPDATE_STATUS	= 16,			// reg 16 status for update_flash											// writing 0x7F means jump to ISP routine
	MODBUS_UART2_BAUDRATE = 18,
	MODBUS_COM0_TYPE = 19,
	MODBUS_COM2_TYPE = 21,
	MODBUS_ETHERNET_STATUS	= 22,
	MODBUS_ENABLE_DEBUG = 23,

	MODBUS_DSL = 25,
	MODBUS_TIME_ZONE = 26,
	MODBUS_SNTP_EN,		//  27
	MODBUS_TIMEZONE_SUMMER,

	MODBUS_INSTANCE_HI = 32,
	MODBUS_TEST_CMD = 33, // NG2
	MODBUS_MINI_TYPE = 34,
	MODBUS_INSTANCE_LO = 35,  //
	MODBUS_PANEL_NUMBER = 36,
	MODBUS_DISPLAY_THEME = 37, // 0 - 9
	MODBUS_STATION_NUM = 42,  // MSTP ID
	MODBUS_NETWORK_NUMBER = 46,
	MODBUS_MSTP_NETWORK, // 47

	MAC_ADDR_1 = 60,
	MAC_ADDR_2,
	MAC_ADDR_3,
	MAC_ADDR_4,
	MAC_ADDR_5,
	MAC_ADDR_6, //65
	IP_MODE, //66
	IP_ADDR_1,
	IP_ADDR_2,
	IP_ADDR_3,
	IP_ADDR_4,
	IP_SUB_MASK_1,//71
	IP_SUB_MASK_2,
	IP_SUB_MASK_3,
	IP_SUB_MASK_4,
	IP_GATE_WAY_1,
	IP_GATE_WAY_2,
	IP_GATE_WAY_3,
	IP_GATE_WAY_4,

	WIFI_RSSI = 80, //80
	MODBUS_TCP_PORT,
	MODBUS_READ_POINT_TIMER = 85,


	Modbus_Fix_Com_Config = 91,
	MODBUS_WRITE_FLASH,  // 92

	MODBUS_RUN_TIME_LO = 94,
	MODBUS_RUN_TIME_HI,

	MODBUS_DEAD_MASTER_FOR_PLC = 96, // ONLY FOR PLC ？？？？？ no used
	MODBUS_LCD_TIME_OFF_DELAY = 98,

	MODBUS_MAX_VARS = 100,
	MODBUS_MAX_INS,
	MODBUS_MAX_OUTS,

	MODBUS_IN1_CAL = 120,
	MODBUS_IN2_CAL,
	MODBUS_IN3_CAL,
	MODBUS_IN4_CAL,
	MODBUS_IN5_CAL,
	MODBUS_IN6_CAL,
	MODBUS_IN7_CAL,
	MODBUS_IN8_CAL,
	MODBUS_IN9_CAL,
	MODBUS_IN10_CAL,
	MODBUS_IN11_CAL,
	MODBUS_IN12_CAL,
	MODBUS_IN13_CAL,
	MODBUS_IN14_CAL,
	MODBUS_IN15_CAL,
	MODBUS_IN16_CAL,

	MODBUS_TIMER_ADDRESS = 200, // 200 + 7

	MODBUS_TOTAL_NO = 299  ,  // NUMBER OF ZONES

	MODBUS_SUBADDR_FIRST = 300 ,	// 193
	MODBUS_SUBADDR_LAST = 400 , // 200

	// ONLY FOR NG2
	MODBUS_NG2_TEMP1 = 500,
	MODBUS_NG2_HUM1,
	MODBUS_NG2_TEMP2,
	MODBUS_NG2_HUM2,
	MODBUS_NG2_TEMP3,
	MODBUS_NG2_HUM3,

	// only for tstat10
	MODBUS_TSTAT10_START = 728,
	MODBUS_ICON_CONFIG = 728,
	MODBUS_DISALBE_TSTAT10_DIS = 729,
	MODBUS_TEMPERATURE = 730,
	MODBUS_TVOC,
	MODBUS_HUMIDY,	// 732
	MODBUS_OCCUPID,
	MODBUS_CO2,  // 734
	MODBUS_LIGHT,
	MODBUS_VOICE,

	MODBUS_PULSE1 = 740,
	MODBUS_PULSE2 ,
	MODBUS_PULSE3 ,
	MODBUS_PULSE4 ,

	MODBUS_CO2_CALIBRATION,

//	MODBUS_DEW_PT = 745,
//	MODBUS_DEW_PT_F,
//	MODBUS_PWS,
//	MODBUS_MIX_RADIO,
//	MODBUS_ENTHALPY,

//	MODBUS_PTERM1 = 800,
//	MODBUS_ITERM1 = 801,
	// type
	// uint8_t number;
//	uint8_t point_type;	 // first 3 bit for number
//	uint8_t panel;
//	uint8_t sub_id;
//	uint8_t	network_number; // networknumber, when first bit is 0

	MODBUS_LCD_CONFIG_FIRST = 800,
	MODBUS_LCD_CONFIG_END = MODBUS_LCD_CONFIG_FIRST + 7/*sizeof(lcdconfig)*/ - 1,

	MODBUS_TSTAT10_END = 807, //

/******** WIFI START ************************/
	MODBUS_WIFI_START = 2000,
	MODBUS_WIFI_SSID_MANUAL_EN = 2000,  // 2001 ~ 2009 reserved
	MODBUS_WIFI_MODE, // 0-AUTO 1-STATIC
	MODBUS_WIFI_STATUS,
	MODBUS_WIFI_RESTORE,
	MODBUS_WIFI_MODBUS_PORT,
	MODBUS_WIFI_BACNET_PORT,
	MODBUS_WIFI_REV, // current is 2
	MODBUS_WIIF_START_SMART,
	MODBUS_WIFI_WRITE_MAC,

	MODBUS_WIFI_SSID_START = 2010,	// 2010 ~ 2041 user name 64 bytes
	MODBUS_WIFI_SSID_END = 2041,
	MODBUS_WIFI_PASS_START = 2042,	// 2042 ~ 2057 password 32 bytes
	MODBUS_WIFI_PASS_END = 2057,

	MODBUS_WIFI_IP1 = 2058 ,
	MODBUS_WIFI_NETMASK = 2062,
	MODBUS_WIFI_GETWAY = 2066,
	MDOBUS_WIFI_MACADDR = 2070,

	MODBUS_WIFI_END = 2100,
/******** WIFI END ************************/
	MODBUS_TASK_TEST = 4000,

    MODBUS_TEST_1 = 7000,
	MODBUS_TEST_50 = 7049,

	MODBUS_IO_REG_START = 7100,
	MODBUS_OUTPUT_FIRST = 7100,
	MODBUS_OUTPUT_LAST = MODBUS_OUTPUT_FIRST + MAX_OUTS * 2 - 1,

	MODBUS_OUTPUT_SWICH_FIRST ,	// 7228
	MODBUS_OUTPUT_SWICH_LAST = MODBUS_OUTPUT_SWICH_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_RANGE_FIRST,  // 7292
	MODBUS_OUTPUT_RANGE_LAST = MODBUS_OUTPUT_RANGE_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_AM_FIRST,  // 7356
	MODBUS_OUTPUT_AM_LAST = MODBUS_OUTPUT_AM_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_AD_FIRST,  // 7420  ANALOG OR DIGITAL
	MODBUS_OUTPUT_AD_LAST = MODBUS_OUTPUT_AD_FIRST + MAX_OUTS - 1,


	MODBUS_INPUT_FIRST,	  // 7484
	MODBUS_INPUT_LAST = MODBUS_INPUT_FIRST + MAX_INS * 2- 1,

	MODBUS_INPUT_FILTER_FIRST,	// 7612
	MODBUS_INPUT_FILTER_LAST = MODBUS_INPUT_FILTER_FIRST + MAX_OUTS - 1,

	MODBUS_INPUT_CAL_FIRST,	  // 7676
	MODBUS_INPUT_CAL_LAST = MODBUS_INPUT_CAL_FIRST + MAX_INS - 1,

	MODBUS_INPUT_CAL_SIGN_FIRST,  // 7740
	MODBUS_INPUT_CAL_SIGN_LAST =  MODBUS_INPUT_CAL_SIGN_FIRST + MAX_INS - 1,

	MODBUS_INPUT_RANGE_FIRST,	  // 7804
	MODBUS_INPUT_RANGE_LAST = MODBUS_INPUT_RANGE_FIRST + MAX_INS - 1,

	MODBUS_INPUT_AM_FIRST,  // 7868
	MODBUS_INPUT_AM_LAST = MODBUS_INPUT_AM_FIRST + MAX_INS - 1,

	MODBUS_INPUT_HI_SPD_COUNTER_FIRST,	  // 7932
	MODBUS_INPUT_HI_SPD_COUNTER_LAST = MODBUS_INPUT_HI_SPD_COUNTER_FIRST + 32/*HI_COMMON_CHANNEL*/ * 2 - 1,

	MODBUS_INPUT_HI_SPD_EN_FIRST, //7996
	MODBUS_INPUT_HI_SPD_EN_LAST = MODBUS_INPUT_HI_SPD_EN_FIRST + 32/*HI_COMMON_CHANNEL*/ - 1,

	MODBUS_INPUT_TYPE_FIRST, // 8028
	MODBUS_INPUT_TYPE_LAST = MODBUS_INPUT_TYPE_FIRST + MAX_INS - 1,

	MODBUS_VAR_FIRST, // 8092
	MODBUS_VAR_LAST = MODBUS_VAR_FIRST + MAX_VARS * 2 - 1,

	MODBUS_VAR_AM_FIRST,  // 8348
	MODBUS_VAR_AM_LAST = MODBUS_VAR_AM_FIRST + MAX_VARS - 1,

	// add weekly roution
	MODBUS_WR_AM_FIRST, // 8476
	MODBUS_WR_AM_LAST = MODBUS_WR_AM_FIRST + MAX_WR - 1,

	MODBUS_WR_OUT_FIRST, // 8484
	MODBUS_WR_OUT_LAST = MODBUS_WR_OUT_FIRST + MAX_WR - 1,

	MODBUS_WR_HOLIDAY1_FIRST, // 8492
	MODBUS_WR_HOLIDAY1_LAST = MODBUS_WR_HOLIDAY1_FIRST + MAX_WR - 1,

	MODBUS_WR_STATE1_FIRST,  // 8500
	MODBUS_WR_STATE1_LAST = MODBUS_WR_STATE1_FIRST + MAX_WR - 1,

	MODBUS_WR_HOLIDAY2_FIRST, // 8508
	MODBUS_WR_HOLIDAY2_LAST = MODBUS_WR_HOLIDAY2_FIRST + MAX_WR - 1,

	MODBUS_WR_STATE2_FIRST,  // 8516
	MODBUS_WR_STATE2_LAST = MODBUS_WR_STATE2_FIRST + MAX_WR - 1,

	// weekly_time
	//	MODBUS_WR_TIME_BYTE_FIRST,
	//	MODBUS_WR_TIME_BYTE_LAST = MODBUS_WR_TIME_BYTE_FIRST + MAX_WR * MAX_SCHEDULES_PER_WEEK * 8 - 1,

	// annual roution
	MODBUS_AR_AM_FIRST,  // 8524
	MODBUS_AR_AM_LAST = MODBUS_AR_AM_FIRST + MAX_AR - 1,

	MODBUS_AR_OUT_FIRST, // 8528 - 8659
	MODBUS_AR_OUT_LAST = MODBUS_AR_OUT_FIRST + MAX_AR - 1,

//	MODBUS_ID_FIRST, // 8532
//	MODBUS_ID_LAST = MODBUS_ID_FIRST + MAX_ID * ID_SIZE - 1,
//	MODBUS_AR_TIME_BYTE_FIRST,
//	MODBUS_AR_TIME_BYTE_LAST = MODBUS_AR_TIME_BYTE_FIRST + MAX_AR * AR_DATES_SIZE - 1,
	MODBUS_VAR_RANGE_FIRST,  // 8532 - 8659
	MODBUS_VAR_RANGE_LAST = MODBUS_VAR_RANGE_FIRST + MAX_VARS - 1,

	MODBUS_VAR_AD_FIRST,  // 8660 - 8787
	MODBUS_VAR_AD_LAST = MODBUS_VAR_AD_FIRST + MAX_VARS - 1,


	MODBUS_OUTPUT_RELINQUISH_START = 9400,
	MODBUS_OUTPUT_RELINQUISH_END = MODBUS_OUTPUT_RELINQUISH_START + 2 * MAX_OUTS - 1,  // 128

	MODBUS_IO_REG_END = MODBUS_OUTPUT_RELINQUISH_END,



/*********FOR CALIBRATE HUM SENSOR******************/
	MODBUS_SETTING_BLOCK_FIRST = 9800,
	MODBUS_USER_BLOCK_FIRST = MODBUS_SETTING_BLOCK_FIRST,

	MODBUS_SETTING_BLOCK_LAST = 9999,

	MODBUS_OUTPUT_BLOCK_FIRST = 10000,     // 10000 -  11471  45
	MODBUS_OUTPUT_BLOCK_LAST = MODBUS_OUTPUT_BLOCK_FIRST + ORIGINAL_OUTS * ((sizeof(Str_out_point) + 1) / 2) - 1,

	MODBUS_INPUT_BLOCK_FIRST, // 11472 - 12943   46
	MODBUS_INPUT_BLOCK_LAST = MODBUS_INPUT_BLOCK_FIRST + ORIGINAL_INS * ((sizeof(Str_in_point) + 1) / 2) - 1,

	MODBUS_VAR_BLOCK_FIRST,  // 12944 - 15503  39
	MODBUS_VAR_BLOCK_LAST = MODBUS_VAR_BLOCK_FIRST + ORIGINAL_VARS * ((sizeof(Str_variable_point) + 1) / 2) - 1,

	MODBUS_PRG_BLOCK_FIRST, // 15504 - 15807   37
	MODBUS_PRG_BLOCK_LAST = MODBUS_PRG_BLOCK_FIRST + MAX_PRGS * ((sizeof(Str_program_point) + 1) / 2) - 1,

	MODBUS_WR_BLOCK_FIRST,  // 15808 -  15975    42
	MODBUS_WR_BLOCK_LAST = MODBUS_WR_BLOCK_FIRST + MAX_WR * ((sizeof(Str_weekly_routine_point) + 1) / 2) - 1,

	MODBUS_AR_BLOCK_FIRST,  // 15976 - 16043   33
	MODBUS_AR_BLOCK_LAST = MODBUS_AR_BLOCK_FIRST + MAX_AR * ((sizeof(Str_annual_routine_point) + 1) / 2) - 1,

	MODBUS_CODE_BLOCK_FIRST, // 16044 - 32043
	MODBUS_CODE_BLOCK_LAST = MODBUS_CODE_BLOCK_FIRST + MAX_PRGS * (CODE_ELEMENT * MAX_CODE / 2) - 1,

	MODBUS_WR_TIME_FIRST,  // 32044 - 32619
	MODBUS_WR_TIME_LAST = MODBUS_WR_TIME_FIRST + MAX_WR * ((sizeof(Wr_one_day) * MAX_SCHEDULES_PER_WEEK + 1) / 2) - 1,

	MODBUS_AR_TIME_FIRST, // 32620 - 32711  46
	MODBUS_AR_TIME_LAST = MODBUS_AR_TIME_FIRST + MAX_AR * (AR_DATES_SIZE / 2) - 1,

	MODBUS_CONTROLLER_BLOCK_FIRST,  // 32712 - 32935  28*16
	MODBUS_CONTROLLER_BLOCK_LAST = MODBUS_CONTROLLER_BLOCK_FIRST + MAX_CONS * ((sizeof(Str_controller_point) + 1) / 2) - 1,

// add customer range
	MODBUS_CUSTOMER_RANGE_BLOCK_FIRST,  // 32936 - 33200  53 * 5
	MODBUS_CUSTOMER_RANGE_BLOCK_LAST = MODBUS_CUSTOMER_RANGE_BLOCK_FIRST + MAX_TBLS * ((sizeof(Str_table_point) + 1) / 2) - 1,

	MODBUS_WR_FLAG_FIRST,  // 33201 - 33488  wr_time_on_off   8 * 9 * 4
	MDOBUS_WR_FLAG_LAST = MODBUS_WR_FLAG_FIRST + MAX_WR * ((MAX_SCHEDULES_PER_WEEK * 8 + 1) / 2) - 1,

	//MODBUS_DIGITAL_TABLE_FIRST, // 33489 - 33592  digi_units 25/2 * 8
	//MODBUS_DIGITAL_TABLE_LAST = MODBUS_DIGITAL_TABLE_FIRST + MAX_DIG_UNIT * ((sizeof(Units_element) + 1) / 2) - 1,
	MODBUS_USER_BLOCK_LAST = 39999,

	MODBUS_EXIO_REG_START = 40000,
//	MODBUS_EX_POINTS_START = 40000,

	MODBUS_EXOUTPUT_FIRST = MODBUS_EXIO_REG_START,
	MODBUS_EXOUTPUT_LAST = MODBUS_EXOUTPUT_FIRST + 192 * 2 - 1,

	MODBUS_EXINPUT_FIRST,	  // 40394
	MODBUS_EXINPUT_LAST = MODBUS_EXINPUT_FIRST + 192 * 2- 1,

	MODBUS_EXVAR_FIRST, // 40788
	MODBUS_EXVAR_LAST = MODBUS_EXVAR_FIRST + 128 * 2 - 1,
	MODBUS_EXIO_REG_END = MODBUS_EXVAR_LAST,


//--------------------------------------------

	MODBUS_AIRLAB_REG_START = BASE_AIRLAB,
	// only for airlab (start)
	MODBUS_AIRLAB_SUB_TYPE,
	MODBUS_LSW_ON_TIME, // only for LSW_SENSOR
	MODBUS_LSW_OFF_TIME,// only for LSW_SENSOR

	MODBUS_AIRLAB_DEGC_OR_F = BASE_AIRLAB + 104,// 					// 0	1	Temperature units  0 = DegC, 1 = DegF
	MODBUS_AIRLAB_TEMPRATURE_CHIP = BASE_AIRLAB + 121,// 121 TEMPRATURE_SENSOR, //101/121 Calibrated temperature chip reading	(0.1 degrees)
	MODBUS_AIRLAB_EXTERNAL_SENSOR1 = BASE_AIRLAB + 139, //CO2	//
	MODBUS_AIRLAB_EXTERNAL_SENSOR2 = BASE_AIRLAB + 140, //HUM

//	TEMP_FILTER = BASE_AIRLAB + 142,//											//		0 = OFF, 1 = trigger unoccupied on falling edge, 2 = occupied high, unoccupied low
//	CO2_FILTER = BASE_AIRLAB + 151,
//	HUM_FILTER = BASE_AIRLAB + 152,
	MODBUS_AIRLAB_CALIBRATION = BASE_AIRLAB + 153,			// 0	255	Thermistor calibration term


	MODBUS_AIRLAB_CO2_CALIBRATION = BASE_AIRLAB + 612, // 612 CO2 calibration data

	MODBUS_AIRLAB_LIGHT_SENSOR = BASE_AIRLAB + 628,  // light sensor value
	MODBUS_AIRLAB_PIR_SENSOR_SELECT = BASE_AIRLAB + 629,
	MODBUS_AIRLAB_PIR_SENSOR_VALUE = BASE_AIRLAB + 630,
	MODBUS_AIRLAB_PIR_SENSOR_ZERO = BASE_AIRLAB + 631,


	MODBUS_AIRLAB_PIR_SPARE = BASE_AIRLAB + 736,

	MODBUS_AIRLAB_PM25_WEIGHT_1_0 = BASE_AIRLAB + 760,
	MODBUS_AIRLAB_PM25_WEIGHT_2_5 = BASE_AIRLAB + 761,
	MODBUS_AIRLAB_PM25_WEIGHT_4_0 = BASE_AIRLAB + 762,
	MODBUS_AIRLAB_PM25_WEIGHT_10 = BASE_AIRLAB + 763,
	MODBUS_AIRLAB_PM25_NUMBER_0_5 = BASE_AIRLAB + 764,
	MODBUS_AIRLAB_PM25_NUMBER_1_0 = BASE_AIRLAB + 765,
	MODBUS_AIRLAB_PM25_NUMBER_2_5 = BASE_AIRLAB + 766,
	MODBUS_AIRLAB_PM25_NUMBER_4_0 = BASE_AIRLAB + 767,
	MODBUS_AIRLAB_PM25_NUMBER_10 = BASE_AIRLAB + 768,
	MODBUS_AIRLAB_HUM_CALIBRATION = BASE_AIRLAB + 769,


//	BACNET_STATION_NUM = BASE_AIRLAB + 977,
//	BACNET_INSTANCE_SPARE,
//	MODBUS_4TO20MA_BOTTOM,
//	MODBUS_4TO20MA_TOP,
//	MODBUS_4TO20MA_UNIT_HI,
//	MODBUS_4TO20MA_UNIT_LO,
	MODBUS_AIRLAB_VOC_INI_BL = BASE_AIRLAB + 983,
	MODBUS_AIRLAB_VOC_BASELINE1,//984
	MODBUS_AIRLAB_VOC_BASELINE2,//985
	MODBUS_AIRLAB_VOC_BASELINE3,
	MODBUS_AIRLAB_VOC_BASELINE4,
	MODBUS_AIRLAB_VOC_DATA,
//	BACNET_INSTANCE_LOW = BASE_AIRLAB + 991,   //991
//	BACNET_INSTANCE_HIGH = BASE_AIRLAB + 992,   //992
	MODBUS_AIRLAB_PATICAL_SIZE,
	MODBUS_AIRLAB_WBGT,     // wet bulb globe temperature



	MODBUS_AIRLAB_CELBRA_AIR1 = BASE_AIRLAB + 1000,
	MODBUS_AIRLAB_CELBRA_AIR2,
	MODBUS_AIRLAB_CELBRA_AIR3,
	MODBUS_AIRLAB_CELBRA_AIR4,
	MODBUS_AIRLAB_AQ_LEVEL0,
	MODBUS_AIRLAB_AQ_LEVEL1,
	MODBUS_AIRLAB_AQ_LEVEL2,
	MODBUS_AIRLAB_MAX_AQ_VAL,
	MODBUS_AIRLAB_CALIBRATION_AQ,

	MODBUS_AIRLAB_AQI = BASE_AIRLAB + 1010,
	MODBUS_AIRLAB_AQI_LEVEL,
	MODBUS_AIRLAB_AQI_AREA,
	MODBUS_AIRLAB_AQI_FIRST_LINE,
	MODBUS_AIRLAB_AQI_SECOND_LINE,
	MODBUS_AIRLAB_AQI_THIRD_LINE,
	MODBUS_AIRLAB_AQI_FOURTH_LINE,
	MODBUS_AIRLAB_AQI_FIFTH_LINE,

//	MODBUS_CO2_ON_TIME = BASE_AIRLAB + 1020,
//	MODBUS_CO2_OFF_TIME,
//	MODBUS_PM25_ON_TIME,
//	MODBUS_PM25_OFF_TIME,

	MODBUS_AIRLAB_CO2_ASC_ENABLE = BASE_AIRLAB + 1950,
	MODBUS_AIRLAB_CO2_FRC_VALUE = BASE_AIRLAB + 1951,

	MODBUS_AIRLAB_DISPLAY_CONFIG5 = BASE_AIRLAB + 1954,
	MODBUS_AIRLAB_IS_BLANK_SCREEN = BASE_AIRLAB + 1955,
	MODBUS_AIRLAB_DISPLAY_CONFIG1 = BASE_AIRLAB + 1956,
	MODBUS_AIRLAB_ = BASE_AIRLAB + 1957,
	MODBUS_AIRLAB_DISPLAY_CONFIG3 = BASE_AIRLAB + 1958,
	MODBUS_AIRLAB_DISPLAY_CONFIG4 = BASE_AIRLAB + 1959,

	MODBUS_AIRLAB_CO2_BKCAL_ONOFF = BASE_AIRLAB + 1960,
	MODBUS_AIRLAB_CO2_NATURE_LEVEL,
	MODBUS_AIRLAB_CO2_MIN_ADJ,
	MODBUS_AIRLAB_CO2_CAL_DAYS = BASE_AIRLAB + 1963,
	MODBUS_AIRLAB_CO2_LOWVALUE_REMAIN_TIME,
	MODBUS_AIRLAB_CO2_BKCAL_VALUE = BASE_AIRLAB + 1965,
	MODBUS_AIRLAB_CO2_LOWVALUE,

	MODBUS_AIRLAB_PM25_TOTAL = BASE_AIRLAB + 1970,
	MODBUS_AIRLAB_PM10_TOTAL,

	// ------ end for airlab

	// ------- START FOR CO2
	MODBUS_CO2_REG_START = BASE_CO2,
	MODBUS_CO2_TEMPERATURE_DEGREE_C_OR_F = BASE_CO2 + 201,
	MODBUS_CO2_INTERNAL_TEMPERATURE_CELSIUS, // 10k
	MODBUS_CO2_INTERNAL_TEMPERATURE_FAHRENHEIT,// 10k
	MODBUS_CO2_EXTERNAL_TEMPERATURE_CELSIUS = BASE_CO2 + 204, // current I2C sensor
	MODBUS_CO2_EXTERNAL_TEMPERATURE_FAHRENHEIT = BASE_CO2 + 205,


	MODBUS_CO2_HUMIDITY = BASE_CO2 + 207, // 207
	MODBUS_CO2_INTERNAL = BASE_CO2 + 211, // 211
	MODBUS_CO2_PREALARM_SETPOINT = BASE_CO2 + 213,
	MODBUS_CO2_ALARM_SETPOINT = BASE_CO2 + 214,


/*	MODBUS_CO2_PASSWORD_ENABLE = BASE_CO2 + 1233,	// 1233
	MODBUS_CO2_USER_PASSWORD0,
	MODBUS_CO2_USER_PASSWORD1,
	MODBUS_CO2_USER_PASSWORD2,
	MODBUS_CO2_USER_PASSWORD3,*/

	MODBUS_CO2_ALARM_AUTO_MANUAL = BASE_CO2 + 1246,	// 1246, bit7: 0 = auto, 1 = manual; bit0:1 = pre_alarm; bit1: 1 = continuous_alarm; bit(1:0): 00 = stop_ alarm
	MODBUS_CO2_PRE_ALARM_SETTING_ON_TIME,
	MODBUS_CO2_PRE_ALARM_SETTING_OFF_TIME,
	MODBUS_CO2_ALARM_DELAY_TIME,

	MODBUS_CO2_OUTPUT_AUTO_MANUAL = BASE_CO2 + 1250,		// 1250
	MODBUS_CO2_OUTPUT_MANUAL_VALUE_TEM,
	MODBUS_CO2_OUTPUT_MANUAL_VALUE_HUM,
	MODBUS_CO2_OUTPUT_MANUAL_VALUE_CO2,

	MODBUS_CO2_OUTPUT_MODE = BASE_CO2 + 1254,				// 1254
	MODBUS_CO2_OUTPUT_RANGE_MIN_TEM,	// 1255
	MODBUS_CO2_OUTPUT_RANGE_MAX_TEM,
	MODBUS_CO2_OUTPUT_RANGE_MIN_HUM,
	MODBUS_CO2_OUTPUT_RANGE_MAX_HUM,
	MODBUS_CO2_OUTPUT_RANGE_MIN_CO2,
	MODBUS_CO2_OUTPUT_RANGE_MAX_CO2,

//	MODBUS_CO2_MENU_BLOCK_SECONDS = BASE_CO2 + 1261,		// 1261
	MODBUS_CO2_BACKLIGHT_KEEP_SECONDS = BASE_CO2 + 1262,

	MODBUS_CO2_LCD_I2C_SENSOR_Index = BASE_CO2 + 2199,// 1999 show which sensor on lcd screen
	// 2200 -
	MODBUS_CO2_I2C_SENOR1_TYPE = BASE_CO2 + 2200, // 0 - no sensor, 1 - SHT31 ,2- SHT4X ,3-SCD40
	MODBUS_CO2_I2C_SENOR1_TEM,
	MODBUS_CO2_I2C_SENOR1_HUM,
	MODBUS_CO2_I2C_SENOR1_CO2,
	MODBUS_CO2_I2C_SENOR1_TEM_OFFSET,
	MODBUS_CO2_I2C_SENOR1_HUM_OFFSET,

	MODBUS_CO2_I2C_SENOR2_TYPE = BASE_CO2 + 2210, // 0 - no sensor, 1 - SHT31 ,2- SHT4X ,3-SCD40
	MODBUS_CO2_I2C_SENOR2_TEM,
	MODBUS_CO2_I2C_SENOR2_HUM,
	MODBUS_CO2_I2C_SENOR2_CO2,
	MODBUS_CO2_I2C_SENOR2_TEM_OFFSET,
	MODBUS_CO2_I2C_SENOR2_HUM_OFFSET,

	MODBUS_CO2_I2C_SENOR3_TYPE = BASE_CO2 + 2220, // 0 - no sensor, 1 - SHT31 ,2- SHT4X ,3-SCD40
	MODBUS_CO2_I2C_SENOR3_TEM,
	MODBUS_CO2_I2C_SENOR3_HUM,
	MODBUS_CO2_I2C_SENOR3_CO2,
	MODBUS_CO2_I2C_SENOR3_TEM_OFFSET,
	MODBUS_CO2_I2C_SENOR3_HUM_OFFSET,

	MODBUS_OUTPUT_HUM = BASE_CO2 + 3066,              // 3066
	MODBUS_OUTPUT_TEMP,
	MODBUS_OUTPUT_CO2,

//	MODBUS_CO2_SCREEN_AREA_1 = BASE_CO2 + 3134, //3134
//	MODBUS_CO2_SCREEN_AREA_2,
//	MODBUS_CO2_SCREEN_AREA_3,
//	MODBUS_CO2_SCREEN_MANUAL_RESET,
//	MODBUS_CO2_ENABLE_SCROLL,
//	MODBUS_CO2_ALARM_ENABLE,


//	MODBUS_CO2_FRC_GET = BASE_CO2 + 3140,
//	MODBUS_CO2_FRC_VALUE,  //3141
//	MODBUS_CO2_CAL, // 3142

	MODBUS_CO2_REG_END,

	// ---------END FOR CO2


	MODBUS_EX_MOUDLE_EN = 65000,
	MODBUS_EX_MOUDLE_FLAG12 = 65001,
	MODBUS_EX_MOUDLE_FLAG34 = 65002,
};

uint16_t read_IO_reg(uint16_t addr);
void Write_IO_reg(uint16_t StartAdd,uint8_t * pData);
void MulWrite_IO_reg(uint16_t StartAdd,uint8_t * pData);

uint16_t read_lightswitch_by_block(uint16_t addr);
void write_lightswitch_by_block(uint16_t addr,uint8_t HeadLen,uint8_t *pData,uint8_t type);
//extern uint8_t dealwithTag ;

//void serial_restart(void);

//void modbus_data_cope(u8 XDATA* pData, u16 length, u8 conn_id) ;
extern void uart_init(uint8_t uart) ;
extern void stm32_uart_init(void);
//uint8_t checkCrc(void);


#endif
void responseModbusCmd(uint8_t type, uint8_t *pData, uint16_t len,uint8_t *resData ,uint16_t *modbus_send_len,uint8_t port);
